<?xml version="1.0" encoding="UTF-8"?>

<!-- Configures the Camel Context-->

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:camel="http://camel.apache.org/schema/spring"
       xmlns:cxf="http://camel.apache.org/schema/cxf"
       xmlns:ctx="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:nc20="http://niem.gov/niem/niem-core/2.0"
       xmlns:firearms-exchange="http://ojbc.org/IEPD/Exchange/FirearmRegistrationQueryResults/1.0"
       xsi:schemaLocation="
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd
       http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd
       ">
       
    <!-- needed cxf imports -->
    <import resource="classpath:META-INF/cxf/cxf.xml"/>

	<camel:camelContext xmlns="http://camel.apache.org/schema/spring" id="firearm-registration-query-request-service-intermediary">
	
		<endpoint id="firearmRegistrationQueryRequestFederatedServiceEndpoint"
			uri="cxf:bean:firearmRegistrationQueryRequestService?dataFormat=PAYLOAD&amp;loggingFeatureEnabled=${firearmQuery.registration.firearmQueryIntermediaryCxflogging}" />

		<endpoint id="firearmRegistrationQueryResultsHandlerServiceEndpoint"
			uri="cxf:bean:firearmRegistrationQueryResultsHandlerService?dataFormat=PAYLOAD&amp;loggingFeatureEnabled=${firearmQuery.registration.firearmQueryIntermediaryCxflogging}" />

	    <endpoint id="firearmRegistrationQueryRequestServiceAdapterEndpoint" 
	    	uri="cxf:bean:firearmRegistrationQueryRequestServiceAdapter?dataFormat=PAYLOAD&amp;loggingFeatureEnabled=${firearmQuery.registration.firearmQueryIntermediaryCxflogging}"/>
		
		<endpoint id="presentFirearmRegistrationQueryResultsServiceEndpoint" 
			uri="cxf:bean:presentFirearmRegistrationQueryResultsService?dataFormat=PAYLOAD&amp;loggingFeatureEnabled=${firearmQuery.registration.firearmQueryIntermediaryCxflogging}"/>                        


		<!-- Federated Search Request Handler-->
		<camel:route>
			<camel:from uri="firearmRegistrationQueryRequestFederatedServiceEndpoint" />
			
			<camel:choice>
				<camel:when>
					<camel:simple>${properties:federatedQuery.firearms.dbAuditLog} == 'true'</camel:simple>
					
					<camel:doTry>
						<camel:to uri="bean:sqlLoggingProcessor?method=logExchange"/>
						
				        <doCatch>
				            <exception>java.lang.Exception</exception>
				            <camel:log message="logging returned exception, handling and continuing: ${exception.message}"/>
				        </doCatch>
					</camel:doTry>
				</camel:when>
			</camel:choice>
			
			<camel:choice>
				<camel:when>
					<camel:method bean="accessControlProcessor" method="authorize" />
					<camel:log message="access control returned true, access message: ${in.headers.accessControlResponseMessage}"/>
				</camel:when>
				<camel:otherwise>
					<camel:log message="access control returned false, access message: ${in.headers.accessControlResponseMessage}"/>
				</camel:otherwise>
			</camel:choice>			
			
			<!-- Get the WS-Addressing ID, set Camel header: federatedQueryRequestGUID -->
			<camel:to uri="bean:messageProcessor?method=processRequestPayload" />

			<!-- Get the SAML Token from the request message and put into OJB SAML Map -->
			<camel:to uri="bean:camelSAMLTokenProcessor?method=retrieveSAMLTokenFromMessage"/>

			<!-- Log pertinent request data -->
			<camel:to uri="bean:federatedQueryAuditLogger?method=auditSearchParameters"/>

			<!-- Perform Xpath query to get list of systems to call and set as Camel Header -->
			<!-- Change this XPath to match what you need -->
			<camel:setHeader headerName="federatedQueryEndpointsNodeList">
				<camel:xpath>//nc20:IdentificationSourceText</camel:xpath>
			</camel:setHeader>
			<camel:log message="endpoints: ${header.federatedQueryEndpointsNodeList}" />
									
			<camel:filter>
				<camel:simple>${in.headers.operationName} == 'SubmitPersonFirearmRegistrationQueryRequest'</camel:simple>
				<camel:log message="Submit Firearms Registation Query by Person operation invoked"/>			
	
				<camel:setHeader headerName="operationName"><constant>SubmitPersonFirearmRegistrationQueryRequest</constant></camel:setHeader>	
			</camel:filter>

			<camel:filter>
				<camel:simple>${in.headers.operationName} == 'SubmitFirearmRegistrationQueryRequest'</camel:simple>
				<camel:log message="Submit Firearms Registation Query by Firearm operation invoked"/>			
	
				<camel:setHeader headerName="operationName"><constant>SubmitFirearmRegistrationQueryRequest</constant></camel:setHeader>	
			</camel:filter>
			
			<camel:setHeader headerName="operationNamespace"><constant>http://ojbc.org/Services/WSDL/FirearmRegistrationQueryRequestService/1.0</constant></camel:setHeader>
									
			<!-- Since this is a query, we only call one endpoint -->						
			<camel:setHeader headerName="adapterURI">
				<camel:xpath resultType="java.lang.String">//nc20:IdentificationSourceText</camel:xpath>
			</camel:setHeader>

			<!-- Add the reply to address to the map using the federated query guid as the key -->
			<camel:to 
				uri="bean:wsAddressingReplyToManager?method=putReplyToAddress"/>
									
			<!-- Call method to populate federated query map and create federatedQueryRecipientListHeader (comma seperated camel endpoint list)-->
			<camel:to
				uri="bean:federatedQueryMessageProcessor?method=processSystemName" />
			
			<!-- This wiretap will start the message timer. There were anamolies with having it as part of the Recipient List -->
			<camel:wireTap uri="direct:startFederatedQueryTimer"/>

			<camel:log message="Timer started"/>

			<camel:split onPrepareRef="prepareFederateQueryMessage" parallelProcessing="false">
				<camel:xpath>//nc20:IdentificationSourceText</camel:xpath>
				<camel:log 
					message="This is the split body: ${body}.  This is the webservice endpoint to call: ${in.headers.webServiceEndpointToCall}" 
					loggingLevel="DEBUG"/>	
				
				<camel:recipientList>
					<camel:header>webServiceEndpointToCall</camel:header>
				</camel:recipientList>
				
			</camel:split>

		</camel:route>			
				      
		<camel:route>
			<from uri="direct:startFederatedQueryTimer"/>
			<setBody>
				<constant>START_QUERY_TIMER</constant>
			</setBody>
			<camel:to uri="direct:aggregateFederatedQuery" />		
		</camel:route>
	
		<!--  Firearm Query Results Handler Route -->
		<camel:route>
			<camel:from uri="firearmRegistrationQueryResultsHandlerServiceEndpoint"/>
			
			<camel:choice>
				<camel:when>
					<camel:simple>${properties:federatedQuery.firearms.dbAuditLog} == 'true'</camel:simple>
					
					<camel:doTry>
						<camel:to uri="bean:sqlLoggingProcessor?method=logExchange"/>
						
				        <doCatch>
				            <exception>java.lang.Exception</exception>
				            <camel:log message="logging returned exception, handling and continuing: ${exception.message}"/>
				        </doCatch>
					</camel:doTry>
				</camel:when>
			</camel:choice>
			
			<camel:log message="Entering Firearm Query Results Handler"></camel:log>
			<camel:setHeader headerName="searchProfile">
				<constant>{http://ojbc.org/Services/WSDL/FirearmRegistrationQueryRequestService/1.0}SubmitFirearmRegistrationQueryRequest</constant>
			</camel:setHeader>
			<camel:to uri="bean:federatedQueryMessageProcessor?method=processFederatedResponse" />
			<camel:log message="Calling Aggregator" />
			<camel:to uri="direct:aggregateFederatedQuery" />
		</camel:route>
	
	    <camel:route>
	      <from uri="direct:aggregateFederatedQuery" />
			<log message="In aggregator with correlation id: ${in.header.federatedQueryRequestGUID}"/>
			<aggregate groupExchanges="true" eagerCheckCompletion="true">
				<correlationExpression>
					<camel:header>federatedQueryRequestGUID</camel:header>
				</correlationExpression>
				<completionTimeout>
					<camel:simple>${properties:firearmQuery.registration.firearmQueryIntermediaryFederatedQueryTimeout}</camel:simple>
				</completionTimeout>
				<completionSize>
					<header>federatedQueryNumberOfEndpointsRequested</header>
				</completionSize>
				<log
					message="completed by ${property.CamelAggregatedCompletedBy}, completion size ${property.CamelAggregatedSize}, aggregation key ${property.CamelAggregatedCorrelationKey}.  Timeout for aggregation set at: ${bean:searchIntermediaryFederatedQueryTimeout.trim}"></log>
				<to
					uri="bean:federatedQueryResponseAggregator?method=aggregateGroupMessagesString" />

				<log message="This is the completed aggregated body: ${body}" loggingLevel="DEBUG"/>
				
				<camel:to uri="direct:processFederatedResponse"/>

			</aggregate>
	      
	    </camel:route>
	    
	    <!-- Process aggregated federated responses here -->
		<camel:route>
			<camel:from uri="direct:processFederatedResponse"/>
				
			<!-- This line remove the OJBWrapper element that the aggregator adds, This XPath works because we only have one response -->
			<camel:setBody><xpath>/OJBAggregateResponseWrapper/*[1]</xpath></camel:setBody>
			
			<camel:to uri="bean:wsAddressingReplyToManager?method=getReplyToAddress"/>

			<camel:to uri="bean:wsAddressingReplyToManager?method=removeReplyToAddress"/>
			
			<camel:to uri="bean:WSAddressingEndpointProcessor?method=processReplyToAddress" />	
				
			<camel:choice>
				<camel:when>
					<camel:simple>${in.headers.recipientListReplyToEndpoint} != ''</camel:simple>
					 
					<camel:log message="This is the operation Name ${in.header.operationName}" loggingLevel="DEBUG"/>
					
					<camel:convertBodyTo type="java.lang.String"/>
			
			        <camel:filter>
						<camel:simple>${in.header.operationName} == 'SubmitPersonFirearmRegistrationQueryResults'</camel:simple>
			        
						<!-- Create new exchange using Camel header as the WS Addressing Message ID -->
						<camel:to uri="bean:messageProcessor?method=prepareNewExchangeResponseMessage"/>
		
						<camel:setHeader headerName="operationName">
							<constant>SubmitPersonFirearmRegistrationQueryResults</constant>
						</camel:setHeader>
			        
			        </camel:filter>
		
			        <camel:filter>
						<camel:simple>${in.header.operationName} == 'SubmitFirearmRegistrationQueryResults'</camel:simple>
			        
						<!-- Create new exchange using Camel header as the WS Addressing Message ID -->
						<camel:to uri="bean:messageProcessor?method=prepareNewExchangeResponseMessage"/>
		
						<camel:setHeader headerName="operationName">
							<constant>SubmitFirearmRegistrationQueryResults</constant>
						</camel:setHeader>
			        
			        </camel:filter>
			        
			        <camel:setHeader headerName="operationNamespace">
						<constant>http://ojbc.org/Services/WSDL/FirearmRegistrationQueryResultsService/1.0</constant>
			        </camel:setHeader>
					
					<camel:to uri="bean:messageProcessor?method=prepareNewExchangeResponseMessage"/>			
					
					<camel:log message="About to send warrants query response message to ${in.headers.recipientListReplyToEndpoint}" />			
								
					<camel:recipientList>
						<camel:header>recipientListReplyToEndpoint</camel:header>
					</camel:recipientList>
				</camel:when>
				<camel:otherwise>
					<camel:log message="Unable to find endpoint for replyTo address: ${in.headers.WSAddressingReplyTo}"/>
				</camel:otherwise>		
			</camel:choice>	

		</camel:route>
	    
	    
	</camel:camelContext>
  
	<!-- Spring Beans -->
	<util:map map-class="java.util.HashMap" id="federatedQueryManager" />

	<bean id="federatedQueryResponseAggregator"
		class="org.ojbc.util.fedquery.processor.FederatedQueryResponseHandlerAggregator">
		<property name="federatedQueryManager">
			<ref bean="federatedQueryManager" />
		</property>
	</bean>

	<bean id="messageProcessor" class="org.ojbc.util.camel.processor.MessageProcessor" />

	<!-- Used to retrieve and persist SAML tokens -->
	<bean id="camelSAMLTokenProcessor" class="org.ojbc.util.camel.security.saml.CamelSAMLTokenProcessor">
		<property name="OJBSamlMap" ref="ojbSamlMap"/>
	</bean>
	<bean id="ojbSamlMap" class="org.ojbc.util.camel.security.saml.OJBSamlMap" />

	<bean id="prepareFederateQueryMessage" class="org.ojbc.util.fedquery.processor.PrepareFederatedQueryMessage">
		<property name="uriToAdapterAddressProcessor" ref="uriToAdapterAddressProcessor"/>
		<property name="federatedQueryEndpointMap" ref="federatedQueryURIToEndpointMap"/>
	</bean>

   	<bean id="WSAddressingEndpointProcessor" class="org.ojbc.util.camel.processor.WSAddressingEndpointProcessor">
		<property name ="endpointReplyToMap" ref="wsAddressReplyToEndpointMap"/>
	</bean>		

    <bean id="federatedQueryMessageProcessor" class="org.ojbc.util.fedquery.processor.FederatedQueryMessageProcessor">
		<property name="federatedQueryManager">
			<ref bean="federatedQueryManager" />
		</property>
	</bean>
	
	<bean class="org.ojbc.util.camel.security.saml.OJBSamlCallbackHandler" id="ojbSamlCallbackHandler">
		<property name="OJBSamlMap" ref="ojbSamlMap"/>
	</bean>
	
	<bean id="wsAddressingReplyToManager" class="org.ojbc.util.fedquery.processor.WSAddressingReplyToManager">
		<property name="wsAddressingEndpointProcessor" ref="WSAddressingEndpointProcessor"/>
	</bean>
	
	<bean id="federatedQueryAuditLogger" class="org.ojbc.util.camel.processor.audit.FederatedQueryAuditLogger">
		<property name="OJBSamlMap" ref="ojbSamlMap"/>
	</bean>
	 
	<bean id="accessControlProcessor" class="org.ojbc.util.camel.processor.accesscontrol.AccessControlProcessor" />
	
	<bean id="uriToAdapterAddressProcessor" class="org.ojbc.util.fedquery.processor.URIToAdapterAddressProcessor">
		<property name="adapterURItoAddressMap" ref="adapterURItoAddressMap"/>
	</bean>
	
</beans>
